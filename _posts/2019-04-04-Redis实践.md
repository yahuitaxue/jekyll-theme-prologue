---
title: Redis实践
author: Yahui
layout: nosql
category: NoSQL
---

《Redis实践》

<pre style="text-align: left;">
<span class="image featured"><img src="{{ 'assets/images/other/nosqlall.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/redistype.jpg' | relative_url }}" alt="" /></span>
(在Linux中安装redis后可以使用redis-cli来使用)
Redis在PHP中的应用
	初始化：
		//连接本地的 Redis 服务
		$redis = new Redis();
		$redis->connect('127.0.0.1', 6379);
		echo "Connection to server successfully";
		     //查看服务是否运行
		echo "Server is running: " . $redis->ping();
	字符串类型(String O(1))：
		使用场景：
			缓存功能：字符串最经典的使用场景，redis最为缓存层，Mysql作为储存层，绝大部分请求数据都是redis中获取，由于redis具有支撑高并发特性，所以缓存通常能起到加速读写和降低 后端压力的作用。
			计数器：许多运用都会使用redis作为计数的基础工具，他可以实现快速计数、查询缓存的功能，同时数据可以一步落地到其他的数据源。如：视频播放数系统就是使用redis作为视频播放数计数的基础组件。
			共享session：出于负载均衡的考虑，分布式服务会将用户信息的访问均衡到不同服务器上，用户刷新一次访问可能会需要重新登录，为避免这个问题可以用redis将用户session集中管理，在这种模式下只要保证redis的高可用和扩展性的，每次获取用户更新或查询登录信息都直接从redis中集中获取。
			限速：处于安全考虑，每次进行登录时让用户输入手机验证码，为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率。
			还有一种用得比较多的是string的incr/decr操作，即自减/自增操作。

			$redis -> set('key','value');
			$redis -> get('key');
			$redis -> del('key');
			$redis->set('key','TK');
			$redis->set('number','1');
			$redis->setex('key',5,'TK'); //设置有效期为5秒的键值
			$redis->psetex('key',5000,'TK'); //设置有效期为5000毫秒(同5秒)的键值
			$redis->setnx('key','XK'); //若键值存在返回false 不存在返回true
			$redis->delete('key'); 删除键值 可以传入数组 array('key1','key2')删除多个键
			$redis->getSet('key','XK'); //将键key的值设置为XK， 并返回这个键值原来的值TK
			$ret = $redis->multi()  //批量事务处理,不保证处理数据的原子性
			    ->set('key1', 'val1')
		        ->get('key1')
		        ->setnx('key', 'val2')
		        ->get('key2')
		        ->exec();
			$redis->watch('key');   // 监控键key 是否被其他客户端修改如果KEY在调用watch()和exec()之间被修改，exec失败
			function f($redis, $chan, $msg) {  //频道订阅
			    switch($chan) {
			        case 'chan-1':
			            echo $msg;
			            break;
			        case 'chan-2':
			            echo $msg;
			            break;
			        case 'chan-2':
			            echo $msg;
			            break;
			    }
			}
			$redis->subscribe(array('chan-1', 'chan-2', 'chan-3'), 'f'); // subscribe to 3 chans
			$redis->publish('chan-1', 'hello, world!'); // send message. 
			$redis->exists('key'); //验证键是否存在，存在返回true
			$redis->incr('number'); //键值加1
			$redis->incrby('number',-10); //键值加减10
			$redis->incrByFloat('number', +/- 1.5); //键值加减小数
			$redis->decr('number'); // 键值减1
			$redis->decrBy('number',10); // 键值减10
			$mget = $redis->mget(array('number','key')); // 批量获取键值,返回一个数组
			$redis->mset(array('key0' => 'value0', 'key1' => 'value1')); // 批量设置键值
			$redis->msetnx(array('key0' => 'value0', 'key1' => 'value1')); // 批量设置键值，类似将setnx()方法批量操作
			$redis->append('key', '-Smudge'); //原键值TK，将值追加到键值后面，键值为TK-Smudge
			$redis->getRange('key', 0, 5); // 键值截取从0位置开始到5位置结束
			$redis->getRange('key', -6, -1); // 字符串截取从-6(倒数第6位置)开始到-1(倒数第1位置)结束
			$redis->setRange('key', 0, 'Smudge'); // 键值中替换字符串，0表示从0位置开始有多少个字符替换多少位置，其中汉字占2个位置
			$redis->strlen('key'); //键值长度
			$redis->getBit('key');
			$redis->setBit('key');
	队列类型(List O(N))：(l与r同理)(队列可以存储相同的字符串)
		使用场景：
			消息队列： redis的lpush+brpop命令组合即可实现阻塞队列，生产者客户端是用lupsh从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞时的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性
			lpush+lpop=Stack(栈) 
			lpush+rpop=Queue（队列） 
			lpush+ltrim=Capped Collection（有限集合） 
			lpush+brpop=Message Queue（消息队列）

			$redis -> lpush('name','value');
			$redis -> lpop('name');
			$redis -> keys("*");// 获取所有队列的名称
			$redis -> llen('name');// 这个没有r
			$redis -> lindex('name',索引位置);// 同样没有r
			$redis -> lrange('name',起始位置,终止位置);// 同样没有r
			$redis -> lrem('name','value',count);// 删除name中count个值为value的
			$redis -> del('name');
			$redis->delete('list-key'); // 删除链表
			$redis->lPush('list-key', 'A'); //插入链表头部/左侧，返回链表长度
			$redis->rPush('list-key', 'B'); //插入链表尾部/右侧，返回链表长度
			$redis->lPushx('list-key', 'C'); // 插入链表头部/左侧,链表不存在返回0，存在即插入成功，返回当前链表长度
			$redis->rPushx('list-key', 'C'); // 插入链表尾部/右侧,链表不存在返回0，存在即插入成功，返回当前链表长度
			$redis->lPop('list-key'); //返回LIST顶部（左侧）的VALUE ,后入先出(栈)
			$redis->rPop('list-key'); //返回LIST尾部（右侧）的VALUE ,先入先出（队列）
			$redis->blPop();
			$redis->brPop();
			$redis->lSize('list-key'); // 如果是链表则返回链表长度，空链表返回0若不是链表或者不为空，则返回false ,判断非链表 " === false "                          
			$redis->lGet('list-key',-1); // 通过索引获取链表元素 0获取左侧一个  -1获取最后一个
			$redis->lSet('list-key', 0, 'X'); //0位置元素替换为 X
			$redis->lRange('list-key', 0, 3); //链表截取 从0开始 3位置结束 ，结束位置为-1 获取开始位置之后的全部
			$redis->lTrim('list-key', 0, 1); // 截取链表(不可逆) 从0索引开始 1索引结束 
			$redis->lRem('list-key', 'C', 2); //链表从左开始删除元素2个C
			$redis->lInsert('list-key', Redis::BEFORE, 'C', 'X'); // 在C元素前面插入X  , Redis::AfTER(表示后面插入) 链表不存在则插入失败 返回0 若元素不存在返回-1
			$redis->rpoplpush('list-key', 'list-key2'); //从源LIST的最后弹出一个元素并且把这个元素从目标LIST的顶部（左侧）压入目标LIST。 
			$redis->brpoplpush(); //rpoplpush的阻塞版本，这个版本有第三个参数用于设置阻塞时间即如果源LIST为空，那么可以阻塞监听timeout的时间，如果有元素了则执行操作。
	散列类型(Hash O(1) 成员各不相同)：
		使用场景：
			哈希结构相对于字符串序列化缓存信息更加直观，并且在更新操作上更加便捷。所以常常用于**用户信息**等管理，但是哈希类型和关系型数据库有所不同，哈希类型是稀疏的，而关系型数据库是完全结构化的，关系型数据库可以做复杂的关系查询，而redis去模拟关系型复杂查询开发困难，维护成本高。

			$redis -> hset('name','key','value');
			$redis -> hget('name','key');
			$redis -> hgetall('name');
			$redis -> hdel('name','key');
			$redis -> del('name');
			$redis->hSet('h', 'name', 'TK'); // 在h表中 添加name字段 value为TK
			$redis->hSetNx('h', 'name', '1TK'); // 在h表中 添加name字段 value为TK 如果字段name的value存在返回false 否则返回 true
			$redis->hGet('h', 'name'); // 获取h表中name字段value
			$redis->hLen('h'); // 获取h表长度即字段的个数
			$redis->hDel('h','email'); // 删除h表中email 字段
			$redis->hKeys('h'); // 获取h表中所有字段
			$redis->hVals('h'); // 获取h表中所有字段value
			$redis->hGetAll('h'); // 获取h表中所有字段和value 返回一个关联数组(字段为键值)
			$redis->hExists('h', 'email'); //判断email 字段是否存在与表h 不存在返回false
			$redis->hSet('h', 'age', 28);
			$redis->hIncrBy('h', 'age', -2); // 设置h表中age字段value加(-2) 如果value是个非数值 则返回false 否则，返回操作后的value
			$redis->hIncrByFloat('h', 'age', -0.33); // 设置h表中age字段value加(-2.6) 如果value是个非数值 则返回false 否则返回操作后的value(小数点保留15位)
			$redis->hMset('h', array('score' => '80', 'salary' => 2000)); // 表h 批量设置字段和value全选复制放进笔记
			$redis->hMGet('h', array('score','salary')); // 表h 批量获取字段的value
			(如果散列包含的值非常大，那么可以先使用HKEYS取出散列包含的所有键，然后再使用HGET一个个的取出键的值，从而避免一次获取多个大体积的值导致服务器阻塞)
	集合类型(Set O(N) 成员各不相同)：
		使用场景：
			标签（tag）：集合类型比较典型的使用场景，如一个用户对娱乐、体育比较感兴趣，另一个可能对新闻感兴趣，这些兴趣就是标签（标签的名字不可以重复，顺序是可以无序的。）有了这些数据就可以得到同一标签的人，以及用户的共同爱好的标签，这些数据对于用户体验以及曾强用户粘度比较重要。（用户和标签的关系维护应该放在一个事物内执行，防止部分命令失败造成数据不一致）
			sadd=tagging（标签）
			spop/srandmember=random item（生成随机数，比如抽奖）
			sadd+sinter=social Graph(社交需求)

			$redis -> sadd('name','value');
			$redis -> smembers('name');// 统计name的所有值
			$redis -> sismember('name','value');// 检测name中是否存在值1
			$redis -> srem('name','value',count);// 删除name中值为value的
			$redis->sMembers('key'); //获取容器key中所有元素
			$redis->sAdd('key' , 'TK'); // (从左侧插入,最后插入的元素在0位置),集合中已经存在TK 则返回false不存在添加成功 返回true
			$redis->sRem('key' , 'TK'); // 移除容器中的TK
			$redis->sMove('key','key1','TK'); //将容易key中的元素TK 移动到容器key1  操作成功返回TRUE
			$redis->sIsMember('key','TK'); //检查VALUE是否是SET容器中的成员
			$redis->sCard('key'); //返回SET容器的成员数
			$redis->sPop('key'); //随机返回容器中一个元素，并移除该元素
			$redis->sRandMember('key');//随机返回容器中一个元素，不移除该元素
			$redis->sInter('key','key1'); // 返回两个集合的交集 没有交集返回一个空数组，若参数只有一个集合，则返回集合对应的完整的数组
			$redis->sInterStore('store','key','key1'); //将集合key和集合key1的交集 存入容器store 成功返回1
			$redis->sUnion('key','key1'); //集合key和集合key1的并集  注意即使多个集合有相同元素 只保留一个
			$redis->sUnionStore('store','key','key1'); //集合key和集合key1的并集保存在集合store中,  注意即使多个集合有相同元素 只保留一个
			$redis->sDiff('key','key1','key2'); //返回数组，该数组元素是存在于key集合而不存在于集合key1 key2
	有序集合类型(Sorted Set O(log(N)))
		使用场景：
			排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。

			$redis->zAdd('name',分数值1,'value1',分数值2,'value2');
		    $redis -> zrange('name',0,-1);从小到大取出数据
		   	$redis -> zRevRange('name',0,1,true);以值为下标，分数为值从大到小取出数据
		    $redis -> zrem($key1,'k1'); // 删除k1
		    $redis -> zRangeByLex($key1,'[k1','[k2')); // 根据value取出value介于k1到k2的值
		    $redis -> zRevRangeByScore($key1,500,0,array('withscores' => true))); // 根据分数值取出0~500之间，由于加上Rev是从大到小，所以分数也需要从大到小
			$redis->zAdd('tkey', 1, 'A'); //  插入集合tkey中，A元素关联一个分数，插入成功返回1同时集合元素不可以重复, 如果元素已经存在返回 0
			$redis->zRange('tkey',0,-1); // 获取集合元素，从0位置 到 -1 位置
			$redis->zRange('tkey',0,-1, true); // 获取集合元素，从0位置 到 -1 位置, 返回一个关联数组 带分数array([A] => 0.01,[B] => 0.02,[D] => 0.03) 其中小数来自zAdd方法第二个参数
			$redis->zDelete('tkey', 'B'); // 移除集合tkey中元素B  成功返回1 失败返回 0
			$redis->zRevRange('tkey', 0, -1); // 获取集合元素，从0位置 到 -1 位置，数组按照score降序处理
			$redis->zRevRange('tkey', 0, -1,true); // 获取集合元素，从0位置 到 -1 位置，数组按照score降序处理 返回score关联数组
			$redis->zRangeByScore('tkey', 0, 0.2,array('withscores' => true)); //获取几个tkey中score在区间[0,0.2]元素 ,score由低到高排序,元素具有相同的score，那么会按照字典顺序排列 , withscores 控制返回关联数组
			$redis->zRangeByScore('tkey', 0.1, 0.36, array('withscores' => TRUE, 'limit' => array(0, 1))); //其中limit中 0和1 表示取符合条件集合中 从0位置开始，向后扫描1个 返回关联数组
			$redis->zCount('tkey', 2, 10); // 获取tkey中score在区间[2, 10]元素的个数
			$redis->zRemRangeByScore('tkey', 1, 3); // 移除tkey中score在区间[1, 3](含边界)的元素
			$redis->zRemRangeByRank('tkey', 0, 1); //默认元素score是递增的，移除tkey中元素 从0开始到-1位置结束
			$redis->zSize('tkey');  //返回存储在key对应的有序集合中的元素的个数
			$redis->zScore('tkey', 'A'); // 返回集合tkey中元素A的score值
			$redis->zRank('tkey', 'A'); // 返回集合tkey中元素A的索引值z集合中元素按照score从低到高进行排列 ，即最低的score index索引为0
			$redis->zIncrBy('tkey', 2.5, 'A'); // 将集合tkey中元素A的score值 加 2.5
			$redis->zUnion('union', array('tkey', 'tkey1')); // 将集合tkey和集合tkey1元素合并于集合union , 并且新集合中元素不能重复返回新集合的元素个数， 如果元素A在tkey和tkey1都存在，则合并后的元素A的score相加
			$redis->zUnion('ko2', array('k1', 'k2'), array(5, 2)); // 集合k1和集合k2并集于k02 ，array(5,1)中元素的个数与子集合对应，然后 5 对应k1 k1每个元素score都要乘以5 ，同理1对应k2，k2每个元素score乘以1 然后元素按照递增排序，默认相同的元素score(SUM)相加
			$redis->zUnion('ko2', array('k1', 'k2'), array(10, 2),'MAX'); // 各个子集乘以因子之后，元素按照递增排序，相同的元素的score取最大值(MAX)也可以设置MIN 取最小值
			$redis->zInter('ko1', array('k1', 'k2')); // 集合k1和集合k2取交集于k01 ，且按照score值递增排序如果集合元素相同，则新集合中的元素的score值相加
			$redis->zInter('ko1', array('k1', 'k2'), array(5, 1)); //集合k1和集合k2取交集于k01 ，array(5,1)中元素的个数与子集合对应，然后 5 对应k1 k1每个元素score都要乘以5 ，同理1对应k2，k2每个元素score乘以1，然后元素score按照递增排序，默认相同的元素score(SUM)相加
			$redis->zInter('ko1', array('k1', 'k2'), array(5, 1),'MAX'); // 各个子集乘以因子之后，元素score按照递增排序，相同的元素score取最大值(MAX)也可以设置MIN 取最小值
		
实例：
	将整个购物车存储到cookie里面，最大优点就是无需对数据库进行写入就可以实现购物车功能，缺点就是程序需要重新解析验证cookie，确保格式正确。另外一个缺点就是浏览器每次发送请求都会连cookie一起发送，如果购物车体积比较大，那么发送和处理的速度会有所降低。

数据持久化
	一种叫快照，可以将存在于某一时刻的所有数据写入硬盘里面。
	一种叫追加文件(AOF)，在执行写命令时，将被执行的写命令复制到硬盘里。	
	将内存中的数据存到硬盘主要原因是为了在之后重用数据，或是为了防止系统故障而将数据备份到一个远程位置。
	redis配置文件,redis.conf
		(快照持久化选项)
			#   900秒（15分钟）内有1个更改
		save 900 1
			#   300秒（5分钟）内有10个更改
		save 300 10
			#   60秒内有10000个更改
		save 60 10000
			# 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大
		rdbcompression yes
			# 如果启用如上的快照（RDB），在一个存盘点之后，可能磁盘会坏掉或者权限问题，redis将依然能正常工作
		stop-writes-on-bgsave-error yes
			# 是否将字符串用LZF压缩到.rdb 数据库中，如果想节省CPU资源可以将其设置成no，但是字符串存储在磁盘上占用空间会很大，默认是yes
		rdbcompression yes
			# 指定本地数据库文件名，默认值为dump.rdb
		dbfilename dump.rdb

		(AOF持久化选项)
			# 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失
		appendonly no
			# 指定更新日志条件，共有3个可选值：
			# no:表示等操作系统进行数据缓存同步到磁盘（快）
			# always:表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）
			# everysec:表示每秒同步一次（折衷，默认值），当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度适应硬盘的最大写入速度
		appendfsync everysec
			# 如果 no-appendfsync-on-rewrite=yes, 这个时候主线程的 set 操作会被阻塞掉, 由于没有新的值写入 redis, 所有就没有这个时候数据丢失的可能. 一旦 tmp.aof 重写成功, 就不会有数据丢失.
			# 如果 no-appendfsync-on-rewrite=no, 这个时候主线程的 set 操作不会阻塞, 就会有新值写入 redis, 但是这部分记录不会同步到硬盘上, 就会有数据丢失的问题可能. 一旦 tmp.aof 重写成功就发生故障, 就会产生数据丢失.
		no-appendfsync-on-rewrite no
			# aof文件增长比例，指当前aof文件比上次重写的增长比例大小。aof重写即在aof文件在一定大小之后，重新将整个内存写到aof文件当中，以反映最新的状态(相当于bgsave)。这样就避免了，aof文件过大而实际内存数据小的问题(频繁修改数据问题).
		auto-aof-rewrite-percentage 100
			# aof文件重写最小的文件大小，即最开始aof文件必须要达到这个文件时才触发，后面的每次重写就不会根据这个变量了(根据上一次重写完成之后的大小).此变量仅初始化启动redis有效.如果是redis恢复时，则lastSize等于初始aof文件大小.
		auto-aof-rewrite-min-size 64mb
	
			# 工作目录，注意，这里只能指定一个目录
		dir /var/lib/redis

			我们的这个Redis示例使用AOF进行持久化(appendonly)，appendfsync策略采用的是everysec刷盘。但是AOF随着时间推移，文件会越来越大，因此，Redis还有一个rewrite策略，实现AOF文件的减肥，但是结果的幂等的。我们no-appendfsync-on-rewrite的策略是 no. 这就会导致在进行rewrite操作时，appendfsync会被阻塞。如果当前AOF文件很大，那么相应的rewrite时间会变长，appendfsync被阻塞的时间也会更长。

			将no-appendfsync-on-rewrite设置为yes. 这样可以避免与appendfsync争用文件句柄，但是在rewrite期间的AOF有丢失的风险。
			给当前Redis实例添加slave节点，当前节点设置为master, 然后master节点关闭AOF，slave节点开启AOF。这样的方式的风险是如果master挂掉，尚没有同步到salve的数据会丢失。
			我们采取了折中的方式：在master节点设置将no-appendfsync-on-rewrite设置为yes，同时添加slave节点。

	快照持久化：只适用于哪些及时丢失一部分数据也不会造成问题的程序：系统发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。
		应用场景：
			1、个人开发。
			2、对日志进行聚合计算：即在将日志处理进度记录到redis中，程序崩溃后，可以根据进度记录继续执行那个之前未完成的处理工作。
			3、大数据：当redis数据量只有几个GB的时候，快照没有问题，但是如果redis内存占用量达到数十个GB那么执行BGSAVE可能会导致系统长时间停顿。
			为了防止Redis创建子进程出现停顿，我们可以考虑关闭自动保存，通过手动发送BGSAVE或者SAVE来进行持久化。虽然SAVE会一直阻塞Redis知道快照生成完毕，但是他不需要创建子进程，不会抢夺资源，所以SAVE创建快照速度会比BGSAVE创建快照的速度要快。
	AOF持久化：
		关键点：
			AOF持久化非常灵活地满足不同应用长须对数据安全的要求，但是AOF持久化也有缺陷，就是AOF文件的体积大小。
		注意：
			为了解决AOF文件体积不断增大的问题，用户可以向Redis发送BGREWRITEAOF命令，会通过移除AOF文件的冗余命令来重写AOF文件，是AOF文件体积尽肯能的小。但是这个命令与BGSAVE类似，创建一个子进程来对AOF文件进行重写。
		方法：
			AOF可以通过设置auto-aof-rewrite-percentage选项和auto-aof-rewrite-min-size选项来自动执行BGREWRITEAOF。举个例子，两个值设置为100和64mb，那么当AOF文件大于64MB并且AOF文件的体积比上一次重写之后的体积打了至少一倍(100%)的时候，Redis将执行BGREWRITEAOF命令，如果AOF重写执行的国语频繁的话，可以考虑第一个在100以上，这种方法可以让Redis在AOF文件的体积变得更大之后才执行重写操作。
	注：
		无论是AOF持久化还是快照持久化，将数据持久化到硬盘上是非常有必要的，但是除了进行持久化之外，用户还需对持久化所得的文件进行备份，这样才能尽量避免数据丢失事故发生。
	复制：
		<span class="image featured"><img src="{{ 'assets/images/other/rediscopy.jpg' | relative_url }}" alt="" /></span>
		(实际中，最好让主服务器使用50%~65%的内存，留下30%~45%的内存用于执行BGSAVE命令)

		Redis Master/Slave 主从配置
			这里我们配置 1台Master +1台Slave 为例子,其中:

		　　　　Master IP：***.***.***.***    Port：6379
		　　　　Slave IP：***.***.***.***     Port：6379

			注意：
				两台机器的IP地址要在同一网段内，否则无法实现集群。两台机器上均按照以上步骤安装并配置好redis服务。在Slave机器上修改配置文件，使其成为Master的从机。命令及配置如下：

		　　　　	#vi /usr/local/webserver/redis/conf/redis.conf
		　　　　	slaveof  ***.***.***.***  6379
		注：Redis不支持主主复制，被互相设置为主服务器的两个Redis只会支持的占用大量处理器资源并且连续不断的城市与对方进行通信，而客户端的请求可能会得到不一致的数据或者得不到数据。
		<span class="image featured"><img src="{{ 'assets/images/other/redistree.jpg' | relative_url }}" alt="" /></span>

系统故障：
	1、验证快照或者AOF文件
		Redis提供了两个命令行程序，他们可以在系统故障发生后，检查AOF文件和快照文件的状态，并在有需要的情况下对文件进行修复。
			redis-check-aof
			Usage: redis-check-aof [--fix] <file.aof>
			redis-check-dump
			Usage: redis-check-dump <dump.rdb>
		如果运行程序是给定了--fix参数，那么程序将对AOF文件进行修复，程序修复AOF文件的方法非常简单，他会扫描给定的AOF文件，寻找不正确或不完整的命令，当发现第一个出错命令的时候，程序会删除出错的命令及之后的所有命令。遗憾的是目前灭有办法可以修复出错的快照文件，因为快照文件本身经过了压缩，而在快照文件中间的错误有可能导致快照文件的剩余部分无法被读取。因此最好为重要的快照文件保留多个备份，并在进行数据恢复时，通过计算快照文件的SHA1和SHA256散列值来对内容进行验证。
	2、更换故障主服务器
		A(主发生故障),B(从),C(备用主)：
			首先向机器B发送一个SAVE命令，让他创建一个新的的快照文件。
			接着将这个快照文件发送给机器C，并在机器C上启动Redis。
			最后将机器B成为机器C的从服务器。
		<span class="image featured"><img src="{{ 'assets/images/other/redisbroken.jpg' | relative_url }}" alt="" /></span>

Redis事务
	以特殊命令MULTI为开始，之后跟着用户传入的过个命令，最后以EXEC为结束。但是由于着用简单的事务在EXEC命令被调用之前不会执行任何实际操作，所以用户将没办法根据读取到的数据来做决定。用户可以使用WATCH命令对键进行监视之后，直到用户执行EXEC命令的这段时间里面，如果有其他客户端抢险对任何监视的键进行了替换、更新或删除等操作，那么当用户尝试执行EXRC的时候，事务将失败并返回一个错误。通过使用WATCH、MULTI/EXEC、UNWATCH/DISCARD等命令，程序可以在执行某些重要操作的时候，通过确保自己正在使用的数据没有发生变化来避免数据出错。
		什么是DISCARD？UNWATCH命令可以在WATCH命令执行之后、MULTI命令执行之前对连接进行重置；同样的DISCARD命令也可以在MULTI命令执行之后EXEC命令执行之前对连接进行重置。这也就是说，用户在使用WATCH监视一个或多个键，接着使用MULTI开始一个新事务、并将多个命令入队到事务队列之后，仍然可以通过发送DISCARD命令来取消WATCH命令清空所有已入队命令。

	Redis只会在数据已经被其他客户端抢先修改了的情况下，通知执行了WATCH命令的哭护短，这种做法称为乐观锁，而关系数据库实际执行的加锁操作称为悲观锁，乐观锁在实际使用中同样非常有效，因为客户端永远不必花时间去等待第一个取得锁的客户端--他们只需要在自己的事务执行失败的时候进行重试就可以了。

非事务性流水线：
	在需要执行大量命令的情况下，及时命令实际上并需要放在事务里面执行，但是为了通过一次发送所有命令来减少通信次数并降低延迟至，用户也可能会将命令包裹在MULTI和EXEC里面执行。但是MULTI和EXEC也会消耗资源，所以可以使用流水线(管道)：
		// 使用管道执行命令
		$redis = new \Redis();
	    $redis->connect('192.168.1.9', 6379);
	    $redis->auth('*****');//密码验证
	    $redis->select(0);//选择库
	    $redis->pipeline();//开启管道
	    foreach ($arr as $key => $value) {
	        $redis->hsetNx('helloworld', (string)$key, $value);
	    }
	    $redis->exec();

		// 通过管道读取，返回一个数组
	    $redis = new \Redis();
	    $redis->connect('192.168.1.9', 6379);
	    $redis->auth('******');
	    $redis->select(0);
	    $redis->pipeline();//开启管道

	    $redis->set('str1', 'h');
	    $redis->set('str2', 'e');
	    $redis->set('str3', 'l');
	    $redis->set('str4', 'l');
	pipeline()传入True或不传参数，那么客户端将使用MULTI和EXEC包裹起用户要执行的所有命令，如果参数为False，那么客户端同样回想执行事务那样收集起用户要执行的所有命令，只是不用MULTI和EXEC包裹起来。如果用户需要向Redis发送多个命令，并且对于这些命令来说，一个命令的执行结果并不会影响另一个命令的输入，并且不需要事务的话，可以传入False参数。
<span class="image featured"><img src="{{ 'assets/images/other/redispipiline.jpg' | relative_url }}" alt="" /></span>
	(经过测试高延迟网络使用流水线是的速度比不使用流水线时的速度快5倍左右)

可以使用redis-benchmark命令对redis进行压测
<span class="image featured"><img src="{{ 'assets/images/other/redisbenchmark.jpg' | relative_url }}" alt="" /></span>

使用Redis构建应用程序组件
	1、自动补全：
		1、如果指定的联系人已经存在于最近联系人列表中，那么从列表中移除他
		2、将指定的联系人添加到最近联系人列表的最前面
		3、如果添加操作完成之后，最近联系人列表包含的联系人数超过了100个，那么对列表进行修剪，只保留列表前的100个联系人
		(这种自动补全，后期还是需要程序进行前缀匹配)
		<span class="image featured"><img src="{{ 'assets/images/other/redisadd_update_contact.jpg' | relative_url }}" alt="" /></span>
	2、通讯录自动补全
		对包含非常多元素的列表进行自动补全，我们必须直接在Redis内部完成查找匹配元素的工作---就用到分值是0的有序集合，如果分值是一样的，那么有序集合将根据成员字符串二进制顺序进行排序。

分布式锁
	乐观锁：
		使用WATCH来构建基本乐观锁
			header("content-type:text/html;charset=utf-8"); 
			$redis = new redis(); 
			$result = $redis->connect('10.10.10.119', 6379); 
			$mywatchkey = $redis->get("mywatchkey"); 
			$rob_total = 100;  //抢购数量 
			if($mywatchkey<$rob_total){ 
				$redis->watch("mywatchkey"); 
				$redis->multi(); 
				//设置延迟，方便测试效果。 
				sleep(5); 
				//插入抢购数据 
				$redis->hSet("mywatchlist","user_id_".mt_rand(1, 9999),time()); 
				$redis->set("mywatchkey",$mywatchkey+1); 
				$rob_result = $redis->exec(); 
				if($rob_result){ 
				$mywatchlist = $redis->hGetAll("mywatchlist"); 
				echo "抢购成功！<br/>"; 
				echo "剩余数量：".($rob_total-$mywaftchkey-1)."<br/>"; 
				echo "用户列表：<pre>"; 
				var_dump($mywatchlist); 
				}else{ 
					echo "手气不好，再抢购！";exit; 
			  	}
			} 

	使用Redis构件锁：
		SETNX命令天生就是和用来实现锁的获取功能，这个命令只会在键不存在的情况下为键设置值，而锁要做的就是将一个随机生成的128位UUID设置为键的值。
		<span class="image featured"><img src="{{ 'assets/images/other/redisachievelock.jpg' | relative_url }}" alt="" /></span>

基于搜索的应用程序
	生成反向索引：
		<span class="image featured"><img src="{{ 'assets/images/other/redisrnindex.jpg' | relative_url }}" alt="" /></span>
		在索引里查找一个单词是非常容易的，程序之需获取单词集合里面的所有文档就可以了。但是要根据两个或多个单词查找文档的话，需要把给定单词集合里面的所有文档都找出来，然后再从中找到哪些在所有单词集合里面都出现了的文档。(SINTER命令和SINTERSTORE命令)
		<span class="image featured"><img src="{{ 'assets/images/other/redisrealindex.jpg' | relative_url }}" alt="" /></span>

构件简单的社交网站
	用户和状态
		用户信息：
			使用Redis的散列来存储用户信息。
			<span class="image featured"><img src="{{ 'assets/images/other/rediswebuser.jpg' | relative_url }}" alt="" /></span>
		状态消息：
			同样使用散列结构来存储状态消息。
			<span class="image featured"><img src="{{ 'assets/images/other/rediswebinfo.jpg' | relative_url }}" alt="" /></span>
		主页时间线：
			<span class="image featured"><img src="{{ 'assets/images/other/rediswebpagecut.jpg' | relative_url }}" alt="" /></span>
		更新关注者列表：
			<span class="image featured"><img src="{{ 'assets/images/other/rediswebupdate.jpg' | relative_url }}" alt="" /></span>
		取消关注：
			<span class="image featured"><img src="{{ 'assets/images/other/rediswebdel.jpg' | relative_url }}" alt="" /></span>
		消息发布：
			<span class="image featured"><img src="{{ 'assets/images/other/rediswebupindex.jpg' | relative_url }}" alt="" /></span>
		消息删除：
			<span class="image featured"><img src="{{ 'assets/images/other/rediswebdelindex.jpg' | relative_url }}" alt="" /></span>

Redis降低内存占用
	不同结构关于使用压缩列表表示的配置选项：
		// 散列结构使用压缩列表表示的限制条件
		hash-max-ziplist-entries 512
		hash-max-ziplist-value 64

		// 列表结构压缩列表表示的限制条件
		list-max-ziplist-entries 512
		list-max-ziplist-value 64

		// 有序结合使用压缩列表表示的限制条件
		zset-max-ziplist-entries 128
		zset-max-ziplist-value 64

		// 集合使用整数集合表示的限制条件
		set-max-intset-entries 512

Redis扩展
	slaveof <masterip> <masterport>命令把它配置为从服务器，当一个从服务器连接至主服务器的时候，从服务器原本存储的所有数据将被清空。最后可以通过向从服务器发送 slaveof no one命令可以让这个从服务器断开与主服务器的连接。
	<span class="image featured"><img src="{{ 'assets/images/other/redisresync.jpg' | relative_url }}" alt="" /></span>
	
	内存容量：
		1、对自己编写的所有方法进行检查，尽可能减少程序需要读取的数据量。
		2、将无关的功能迁移至其他服务器。
		3、对Redis进行写入之前，尝试在本地内存中将要写入的数据进行聚合计算，这一做法可以应用于所有分析方法和统计计算方法。
		4、使用锁去替换可能会给速度带来限制的 WATCH/MULTI/EXEC事务。
		5、在使用AOF持久化的情况下，机器的硬盘必须将程序写入的所有数据都存储起来，这需要花费一定的时间。
</pre>