---
title: MySQL与数据库维护
author: Yahui
layout: mysql
category: MySQL
---

MySQL与数据库维护

<pre style="text-align: left;">
<h1>基础部分</h1>
SQL 语句主要可以划分为以下 3 个类别。

DDL（Data Definition Languages）语句：数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。

DML（Data Manipulation Language）语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）

DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。

数据库子查询：
	用于子查询的关键字包括：in,notin,=,!=,exist,not exist;

数据库记录联合：
	UNION/UNION ALL主要区别是UNION ALL是把结果直接结合在一起，而UNION是将UNION ALL的结果再进行一次DISTINCT。
	例：SELECT a FROM table1 UNION/UNION ALL SELECT a FROM table2;

数据库DCL
	用于DBA管理系统中对象权限
	grant select,insert on 数据库.* to '用户名'@'localhost' identified by '用户密码'(创建一个数据库用户，具有对数据库中所有表的SELECT/INSERT权限)
<span class="image featured"><img src="{{ 'assets/images/other/mysqldclgrant.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqldclrevoke.jpg' | relative_url }}" alt="" /></span>
	revoke insert on 数据库.* from '用户名'@'localhost'

数据库类型
	整型int
		后面加小括号内指定显示宽度。例如int(5)表示宽度小于5的时候在数字前面进行填充，一般配合zerofill使用。如果不指定宽度，默认是(11)。如果插入数据大于指定宽度只要在类型范围内，也不会报错，会将实际数值保存。
	字符串型
		CHAR的长度是定义时的长度0~255
		VARCHAR的长度是可变的
		还有一个区别，CHAR会忽略字符串最后的空格，而VARCHAR则不会忽略
	枚举ENUM类型
		对1~255个成员，用一个字节存储，255~65535个成员用两个字节存储
		枚举类型忽略大小写，如果不在枚举范围内，则默认插入第一个值。
	SET类型
		与枚举型类似，区别在于SET一次可以选取多个成员，而ENUM只能选取一个。
<span class="image featured"><img src="{{ 'assets/images/other/mysqlset.jpg' | relative_url }}" alt="" /></span>
	(select 'abc'>'a','bc'>'a';)

数据库常用函数
<span class="image featured"><img src="{{ 'assets/images/other/mysqlstring.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqlnumber.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqldatetime.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqlcondition.jpg' | relative_url }}" alt="" /></span>

<h1>开发篇</h1>
<span class="image featured"><img src="{{ 'assets/images/other/mysqlengine.jpg' | relative_url }}" alt="" /></span>
MyISAM引擎中，物理文件有三个
表名.frm(表定义)
表名.MYD(表数据)
表名.MYI(表索引)
对于InnoDB，自动增长的列必须是索引，如果是组合索引，也必须是组合索引的第一列；但是对于MyISAM表，自动增长的可以是组合索引的其他列。
	(FOREIGN KEY(字段名) REFERENCES 表名(字段名))
	ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(字段) REFERENCES 表名(字段名)
<code>
	(注：此处为网上整理而来)
	FULLTEXT

	即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE INDEX创建FULLTEXT索引，要比先为一张表建立FULLTEXT然后再将数据写入的速度快很多。

	全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。在没有全文索引之前，这样一个查询语句是要进行遍历数据表操作的，可见，在数据量较大时是极其的耗时的，如果没有异步IO处理，进程将被挟持，很浪费时间，当然这里不对异步IO作进一步讲解，想了解的童鞋，自行百度。

	全文索引的使用方法并不复杂：

	创建ALTER TABLE table ADD INDEX `FULLINDEX` USING FULLTEXT(`cname1`[,cname2…]);

	使用SELECT * FROM table WHERE MATCH(cname1[,cname2…]) AGAINST ('word' MODE );

	其中， MODE为搜寻方式（IN BOOLEAN MODE ，IN NATURAL LANGUAGE MODE ，IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION / WITH QUERY EXPANSION）。

	关于这三种搜寻方式，在这里也不多做交代，简单地说，就是，布尔模式，允许word里含一些特殊字符用于标记一些具体的要求，如+表示一定要有，-表示一定没有，*表示通用匹配符，是不是想起了正则，类似吧；自然语言模式，就是简单的单词匹配；含表达式的自然语言模式，就是先用自然语言模式处理，对返回的结果，再进行表达式匹配。

	对搜索引擎稍微有点了解的同学，肯定知道分词这个概念，FULLTEXT索引也是按照分词原理建立索引的。西文中，大部分为字母文字，分词可以很方便的按照空格进行分割。但很明显，中文不能按照这种方式进行分词。那又怎么办呢？这个向大家介绍一个Mysql的中文分词插件Mysqlcft，有了它，就可以对中文进行分词，想了解的同学请移步Mysqlcft，当然还有其他的分词插件可以使用。

	HASH

	Hash这个词，可以说，自打我们开始码的那一天起，就开始不停地见到和使用到了。其实，hash就是一种（key=>value）形式的键值对，如数学中的函数映射，允许多个key对应相同的value，但不允许一个key对应多个value。正是由于这个特性，hash很适合做索引，为某一列或几列建立hash索引，就会利用这一列或几列的值通过一定的算法计算出一个hash值，对应一行或几行数据（这里在概念上和函数映射有区别，不要混淆）。在java语言中，每个类都有自己的hashcode()方法，没有显示定义的都继承自object类，该方法使得每一个对象都是唯一的，在进行对象间equal比较，和序列化传输中起到了很重要的作用。hash的生成方法有很多种，足可以保证hash码的唯一性，例如在MongoDB中，每一个document都有系统为其生成的唯一的objectID（包含时间戳，主机散列值，进程PID，和自增ID）也是一种hash的表现。额，我好像扯远了-_-!

	由于hash索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。那为什么还需要其他的树形索引呢？

	在这里就不自己总结了。引用下网上其他大神的文章

	（1）Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。 
	由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。 
	（2）Hash 索引无法被用来避免数据的排序操作。 
	由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； 
	（3）Hash 索引不能利用部分索引键查询。 
	对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 
	（4）Hash 索引在任何时候都不能避免表扫描。 
	前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 
	（5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 
	对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。

	当我们为某一列或某几列建立hash索引时（目前就只有MEMORY引擎显式地支持这种索引），会在硬盘上生成类似如下的文件：

	hash值 	存储地址    
	1db54bc745a1	77#45b5 
	4bca452157d4	76#4556,77#45cc…
	…

	hash值即为通过特定算法由指定列数据计算出来，磁盘地址即为所在数据行存储在硬盘上的地址（也有可能是其他存储地址，其实MEMORY会将hash表导入内存）。

	这样，当我们进行WHERE age = 18 时，会将18通过相同的算法计算出一个hash值==>在hash表中找到对应的储存地址==>根据存储地址取得数据。

	所以，每次查询时都要遍历hash表，直到找到对应的hash值，如（4），数据量大了之后，hash表也会变得庞大起来，性能下降，遍历耗时增加，如（5）。

	BTREE

	BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中。如二叉树一样，每次查询都是从树的入口root开始，依次遍历node，获取leaf。

	BTREE在MyISAM里的形式和Innodb稍有不同

	在 Innodb里，有两种形态：
	一是primary key形态，其leaf node里存放的是数据，而且不仅存放了索引键的数据，还存放了其他字段的数据。
	二是secondary index，其leaf node和普通的BTREE差不多，只是还存放了指向主键的信息.

	而在MyISAM里，主键和其他的并没有太大区别。不过和Innodb不太一样的地方是在MyISAM里，leaf node里存放的不是主键的信息，而是指向数据文件里的对应数据行的信息.

	RTREE

	RTREE在mysql很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。

	相对于BTREE，RTREE的优势在于范围查找.

	各种索引的使用情况

	（1）对于BTREE这种Mysql默认的索引类型，具有普遍的适用性

	（2）由于FULLTEXT对中文支持不是很好，在没有插件的情况下，最好不要使用。其实，一些小的博客应用，只需要在数据采集时，为其建立关键字列表，通过关键字索引，也是一个不错的方法，至少我是经常这么做的。

	（3）对于一些搜索引擎级别的应用来说，FULLTEXT同样不是一个好的处理方法，Mysql的全文索引建立的文件还是比较大的，而且效率不是很高，即便是使用了中文分词插件，对中文分词支持也只是一般。真要碰到这种问题，Apache的Lucene或许是你的选择。

	（4）正是因为hash表在处理较小数据量时具有无可比拟的素的优势，所以hash索引很适合做缓存（内存数据库）。如mysql数据库的内存版本Memsql，使用量很广泛的缓存工具Mencached，NoSql数据库redis等，都使用了hash索引这种形式。当然，不想学习这些东西的话Mysql的MEMORY引擎也是可以满足这种需求的。
	CREATE INDEX 索引名 ON 表名(字段名,字段名...)
	ALTER TABLE 表名 ADD INDEX 索引名 (字段名,字段名...)
	DROP INDEX 索引名 ON 表名
	ALTER TABLE 表名 DROP INDEX 索引名
		联合索引(a,b,c)索引可以支持a|a,b|a,b,c 3种组合进行查找
</code>
对于MEMORY存储引擎，在不再需要的时候，需要释放表的内存：DELETE FROM / TRUNCATE TABLE / DROP TABLE

对于MERGE存储引擎：是一组MyISAM表的组合，这些表需要结构完全一样，MERGE表本身并没有数据，对MERGE表可以进行查询，更新和删除这些实际是对MyISAM表进行的，对于插入操作，是通过INSERT_METHOD定义插入的表，可以有三个值：FIRST，LAST，不定义(或设置为NO)，表示不能对这个表进行插入操作。
<span class="image featured"><img src="{{ 'assets/images/other/mysqlmerge.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqlenginebetter.jpg' | relative_url }}" alt="" /></span>

CHAR与VARCHAR
<span class="image featured"><img src="{{ 'assets/images/other/mysqlcharorvarchar.jpg' | relative_url }}" alt="" /></span>

TEXT与BLOB
	BLOB用来保存二进制数据，比如图片
	TEXT只能保存字符串数据

(注：平时的删除操作，会在数据表中留下很大的空洞，会导致物理占用没必要的空间,可以使用  mysql>OPTIMIZE TABLE test; 语法进行碎片整理)
(注：可以使用合成索引(就是根据大文本字段(BLOB/TEXT)的内容建立一个散列值(可以使用MD5来生成))并把这个值存在一个新的字段中，这样就可以使用散列值查询数据)

浮点数与定点数
	浮点数表示时，单精度表示浮点数会有些许误差，所以要求精度比较高的应用中(比如货币)，最好使用定点数，而且尽量避免浮点数的比较，如果非要比较，最好使用范围比较，而不要用 "==" 来比较

时间日期
	如果只需记录年份可以使用YEAR类型，如果是日期可以使用DATE，如果是精确时间可以使用DATETIME，如果需要区分时区可以使用TIMESTAMP。
	DATETIME与TIMESTAMP显示形式是一样的，区别在于：
		对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。
		而对于DATETIME，不做任何改变，基本上是原样输入和输出。

(GBK中中文占用两个字节，UTF-8占用三个字节，使用mysql>show character set;可以查看)
(查看数据库默认字符集(show variables like 'character_set_database';)与默认校对规则(show variables like 'collation_database';))
(设置数据库默认字符集set character_set_database = utf8;)

索引的设计原则
<span class="image featured"><img src="{{ 'assets/images/other/mysqlindex.jpg' | relative_url }}" alt="" /></span>

HASH索引
	只能用于使用 = 或者 <=>(与=类似区别在于与NULL作比较的时候) 操作符的等式比较
	优化器不能通过HASH来加速ORDER BY操作
	MySQL不能确认两个值之间有多少行。如果将一个MyISAM改为HASH索引的MYMORY表，会影响一些查询效率
	只能用整个关键字来搜索一行
BTREE索引
	当使用 >,<,>=,<=,BETWEEN,!= 或者 <>,LIKE 'abc'(其中'abc'不以通配符开始)操作时，都可以使用相关列上的索引

视图：
	创建视图：
		CREATE OR REPLACE view 视图名 AS (查询结果);
		MySQL创建视图有一些限制：在FROM后不能有子查询，可以先将子查询作为一个视图，然后再根据这个视图创建下一个视图。
	查看视图：
		SHOW TABLES;
		SHOW CREATE VIEW 视图名;

存储过程
	创建存储过程
		DROP PROCEDURE IF EXISTS `存储过程名`;
		DELIMITER ;;
		CREATE DEFINER=`mysql`@`%` PROCEDURE `存储过程名`()
		BEGIN
			(DDL语句)
			...
		    DELETE FROM ... WHERE ...;
		    INSERT INTO ... SELECT ... FROM ... WHERE PRI_T...;
		    TRUNCATE TABLE  ...;
		    ...
		COMMIT;
		END
		;;
		DELIMITER ;
<span class="image featured"><img src="{{ 'assets/images/other/mysqlprocedure.jpg' | relative_url }}" alt="" /></span>

	删除存储过程
		DROP PROCEDURE 存储过程名称

	查看存储过程
		SHOW PROCEDURE STATUS (LIKE '');
		SHOW CREATE {PROCEDURE|FUNCTION} 存储过程名称
存储过程中可以声明变量(DELCARE 名 类型)
变量赋值(SET 名=表达式)
定义条件(DELCARE 条件名 CONDITION FOR 条件值，然后在下面类似PHP中case的形式声明条件名与条件值是什么)
光标(DECLARE 光标名 CURSOR FOR 查询状态(SELECT a,b FROM 表名;))
以及使用IF，CASE，LOOP，LEAVE，ITERATE，REPEAT，WHILE

事件调度器(定时触发，类似crontab，MySQL版本要在5.1版本以上)
CREATE EVENT 事件名
ON SCHEDULE AT(EVERY 5 SECOND) CURRENT_TIMESTAMP + INTERVAL 1 HOUR
DO
	UPDATE 表名 SET ......;
注：复杂的逻辑更适合程序实现

触发器
	触发器只能建立在永久表上，临时表不能创建
	触发器中不能有开始或者结束事务的语句：START TRANSACTION COMMIT ROLLBACK
	DELIMITER $$;
	CREATE TRIGGER 触发器名 AFTER(/BEFORE) INSERT(/UPDATE...) ON 触发的表名 FOR EACH ROW
	BEGIN
		(触发事件)
		INSERT INTO 表名(字段,字段,,,) VALUES (new(old更新的话，可以用到旧字段).字段,new(old).字段,,,);
	END;
	$$
	DELIMITER ;
	删除触发器
	DROP TRIGGER 触发器名称

表锁
	LOCK TABLE 表名 READ/WRITE;
	锁上以后，只是把这个表临时归为私有，等解锁以后就可以了。
	UNLOCK TABLES;

事务
	START TRANSACTION/BEGIN
	COMMIT
	ROLLBACK
	在使用START TRANSACTION/BEGIN的时候会默认执行UNLOCK TABLES

表分区
	使用SHOW VARIABLES (LIKE '%partition%')查看是否支持分区
	MySQL支持大多数的存储引擎(MyISAM，InnoDB，Memory等)分区，但不支持MERGE或CSV来创建分区。
	注：同一个分区表的所有分区存储引擎必须一致
	MySQL分区适用所有数据和索引，不能对数据而不对索引，也不能对索引不对数据，同时也不能对部分数据进行分区

	分区类型
		RANGE：基于一个给定连续区间，把数据分配到不通分区。(分区的键必须是INT或者返回是INT类型的，5.5版本以上支持非整型)
		LIST：与RNAGE类似，不同的是LIST是基于枚举型的值列表分区，RANGE是基于给定的连续范围区间分区。(分区的键必须是INT或者返回是INT类型的，5.5版本以上支持非整型)
		HASH：基于给定的分区，把数据分配到不同的分区。(分区的键必须是INT或者返回是INT类型的)
		KEY：类似HASH(???)。(可以使用其他类型的做为分区TEXT与BOLB除外)
		注：要么分区表上没有主键/唯一键，要么分区表的主键/唯一键必须包含分区键，也就是说不能使用主键/唯一键以外的其他字段

		RANGE:
<span class="image featured"><img src="{{ 'assets/images/other/mysqlpartition.jpg' | relative_url }}" alt="" /></span>
		(如果分区键超过了分区时定义的最大值，就会出现不能插入的情况，可以使用：PARTITION Pn VALUES LESS THAN MAXVALUE)
		(当需要删除分区数据的时候，可以使用ALTER TABLE 表名 DROP PARTITION 分区名;这要比使用DELETE语句更便捷)
		LIST：语法PARTITION BY LIST COLUMNS()
			PARTITION 名称 VALUES IN(字段值,字段值,字段值)
<span class="image featured"><img src="{{ 'assets/images/other/mysqlpartitionrange.jpg' | relative_url }}" alt="" /></span>
		HASH：PARTITION BY (LINEAR)(如果加上LINEAR就是线性HASH算法) HASH(字段) PARTITIONS 4;利用hash创建4个分区，按照字段与4取余计算
		因为HASH分区完成后，如果需要新增分区，则需要数据重新计算分区，很麻烦，所以可以使用线性HASH
		线性HASH：PARTITION BY LINEAR HASH(字段) PARTITIONS 4;(优点：分区维护(增、删、合并与拆分)更加便捷，缺点各个分区数据不太均衡)
<span class="image featured"><img src="{{ 'assets/images/other/mysqlpartitionhash.jpg' | relative_url }}" alt="" /></span>
		KEY：可以使用PARTITION BY KEY(必须为INT类型，可以不写，默认优先级主键->非空唯一键) PARTITIONS 4;
		在KEY中使用LINEAR与HASH相同。

	子分区
		与分区语法一样，可以使用在分区下来定义子分区
<span class="image featured"><img src="{{ 'assets/images/other/mysqlpartitionchildren.jpg' | relative_url }}" alt="" /></span>

	注意：NULL值问题，RANGE分区中NULL会被当成最小的值来处理，LIST中NULL必须出现在枚举型中，HASH/KEY中NULL会被当成0值

	RANGE分区：
		增加分区：ALTER TABLE 表名 ADD PARTITION ( PARTITIONS 分区名 VALUES LESS THAN (值));新增分区只能增加到最大值部分
		分区增加值：
			1、以新值增加新的分区
			2、修改！！相邻！！的分区，对值进行重新分配(ALTER TABLE 表名 REORGANIZE PARTITION p4,p5,p6 INTO( ... ))
<span class="image featured"><img src="{{ 'assets/images/other/mysqlreorganizepartition.jpg' | relative_url }}" alt="" /></span>
	HASH与KEY分区：
		增加分区：ALTER TABLE 表名 ADD PARTITION PARTITIONS 增加的数量;
		减少分区：ALTER TABLE 表名 COLASESCE APRTITION 减少的数量;
取消分区：
	ALTER TABLE 表名 REMOVE PARTITIONING;

<h1>优化篇</h1>
	使用SHOW STATUS LIKE 'Com_%';来查看当前session中SQL的执行频率。
	SHOW PROCESSLIST;查看在进行的线程。
	使用DESC/EXPLAIN + SQL语句 //查看执行情况
	使用DESC/EXPLAIN + PARTITIONS SQL语句 //查看执行分区

1、通过慢查询定位执行时间过长的SQL语句 (用--log-slow-queries[=file_name]选项启动mysqld的时候会执行时间超过long_query_time的SQL语句)
2、通过DESC/EXPLAIN + SQL语句 (查看SQL的执行信息)
	select_type:表示SELECT的类型
				SIMPLE：简单表，不适用表连接或者子查询
				PRIMARY：主查询
				UNION：UNION中的第二个或者后面的下旬语句
				SUBQUERY：子查询中的第一个SELECT
	table:输出结果集的表
	type:表示MySQL在列表中找到所需行的方式，或者访问类型，插件类型
		ALL(遍历全表进行匹配如：explain select * from a where 非索引列 > 9)
		index(遍历整个索引进行匹配如：explain select 索引列 from a)
		range(索引范围匹配，常见于<,<=,>,>=,between等如：explain select * from a where 索引列 > 9)
		ref(使用非唯一索引返回某个单独值的记录如：explain select * from a where 索引列 = 9)
		eq_ref(多表查询使用唯一索引使用primary key或者unique index作为关联，并且关联是只有一个对应的条件如：explain select * from 表1,表2 where 表1.id = 表2.id)
		const,system(单表中最多有一个匹配行如：explain select * from(select * from a where 主键索引或者唯一索引 = '某个值'))
		NULL(MySQL不用访问表或者索引就能得到结果如：explain select 1+2;)
		(性能由差到好)
3、通过SHOW PROFILE分析SQL
	查看是否支持profile：select @@profile;
	设置profile是否开启：set profiling = 1;
	通过show profiles;查看执行SQL;
	再通过show profiles for query 1;来查看每个状态消耗的时间
	再通过 show profile all/cpu/block io/context/switch/page faults... for query 1;来查看SQL执行的详情
</pre>