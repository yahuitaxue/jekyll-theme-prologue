---
title: PHP功能强大函数
author: Yahui
layout: php
category: PHP
---

PHP强大函数整理

<pre style="text-align: left;">
<h1>接收参数过滤函数使用filter_input();</h1>

filter_input(input_type, variable, filter, options)	从脚本外部获取输入，并进行过滤。

参数说明：

input_type  必需。规定输入类型。参见上面的列表中可能的类型。

INPUT_GET

INPUT_POST

INPUT_COOKIE

INPUT_ENV

INPUT_SERVER

INPUT_SESSION (Not yet implemented)

INPUT_REQUEST (Not yet implemented)

variable    规定要过滤的变量。

filter  可选。规定要使用的过滤器的 ID。默认是 FILTER_SANITIZE_STRING。

FILTER_CALLBACK	调用用户自定义函数来过滤数据。

FILTER_SANITIZE_STRING	去除标签，去除或编码特殊字符。

FILTER_SANITIZE_STRIPPED	"string" 过滤器的别名。

FILTER_SANITIZE_ENCODED	URL-encode 字符串，去除或编码特殊字符。

FILTER_SANITIZE_SPECIAL_CHARS	HTML 转义字符 '"<>& 以及 ASCII 值小于 32 的字符。

FILTER_SANITIZE_EMAIL	删除所有字符，除了字母、数字以及 !#$%&'*+-/=?^_`{|}~@.[]

FILTER_SANITIZE_URL	删除所有字符，除了字母、数字以及 $-_.+!*'(),{}|\\^~[]`<>#%";/?:@&=

FILTER_SANITIZE_NUMBER_INT	删除所有字符，除了数字和 +-

FILTER_SANITIZE_NUMBER_FLOAT	删除所有字符，除了数字、+- 以及 .,eE。

FILTER_SANITIZE_MAGIC_QUOTES	应用 addslashes()。

FILTER_UNSAFE_RAW	不进行任何过滤，去除或编码特殊字符。

FILTER_VALIDATE_INT	在指定的范围以整数验证值。

FILTER_VALIDATE_BOOLEAN	如果是 "1", "true", "on" 以及 "yes"，则返回 true，如果是 "0", "false", "off", "no" 以及 ""，则返回 false。否则返回 NULL。

FILTER_VALIDATE_FLOAT	以浮点数验证值。

FILTER_VALIDATE_REGEXP	根据 regexp，兼容 Perl 的正则表达式来验证值。

FILTER_VALIDATE_URL	把值作为 URL 来验证。

FILTER_VALIDATE_EMAIL	把值作为 e-mail 来验证。

FILTER_VALIDATE_IP	把值作为 IP 地址来验证。

options 规定包含标志/选项的数组。检查每个过滤器可能的标志和选项。

<hr/>

<h1>filter_input_array()	从脚本外部获取多项输入，并进行过滤。</h1>

参数说明：

array	必需。规定带有字符串键的数组，包含要过滤的数据。

args    可选。规定过滤器参数数组。

例：

$arr = array("name" => "peter griffin","age" => "41","email" => "peter@example.com",);

$filters = array("name" => array("filter"=>FILTER_CALLBACK,"flags"=>FILTER_FORCE_ARRAY,"options"=>"ucwords"),"age" => array("filter"=>FILTER_VALIDATE_INT,"options"=>array("min_range"=>1,"max_range"=>120)),"email"=> FILTER_VALIDATE_EMAIL,);

print_r(filter_var_array($arr, $filters));


<h1>trait用法</h1>

PHP是单继承的语言，在PHP 5.4 Traits出现之前，PHP的类无法同时从两个基类继承属性或方法。php的Traits和Go语言的组合功能有点类似，

通过在类中使用use关键字声明要组合的Trait名称，而具体某个Trait的声明使用trait关键词，Trait不能直接实例化。具体用法请看下面的代码：
trait Drive {
    public function hello() {
        echo "this is hello\n";
    }
    public function driving() {
        echo "this is driving\n";
    }
}
class Person {
    public function hello() {
        echo "this is other hello\n";
    }
    public function driving() {
        echo "this is other driving\n";
    }
}
class Student extends Person {
    use Drive;//trait 的方法覆盖了基类Person中的方法，所以Person中的hello 和driving被覆盖
    public function hello() {
        echo "this is my hello\n";//当方法或属性同名时，当前类中的方法会覆盖 trait的 方法,所以此处hello会覆盖trait中的hello
    }
}
$student = new Student();
$student->hello();
$student->driving();

this is my hello
this is driving


<h1>heredoc 和 nowdoc 的语法</h1>
heredoc 开始行有三个左尖括号加一个标识符组成， 结束行只有标识符，前后无空格，作为php的一条语句，最后的分号是不能少的。
heredoc的示例

$test = 'this is test';

$str = <<<\EOT
string  -- $test
// 这里不是注释，会被输出
这个单独的一行
EOT;
最终输出的结果

string  -- this is test
// 这里不是注释，会被输出
这个单独的一行
nowdoc和heredoc的区别是，语法上，开始行的标识符需要用单引号包括起来。结束标志是相同的。
nowdoc的示例

$test = 'this is test';
$str = <<<'EOT'
string  -- $test -- 这里的 $test不会被解析
// 这里不是注释，会被输出
这个单独的一行 \n\n\n
EOT;
echo $str;
输出的结果

string  -- $test -- 这里的 $test不会被解析
这里不是注释，会被输出
这个单独的一行 \n\n\n
nowdoc和heredoc的最大区别是就不解析变量和符合双引号转义规则的字符组合。


<h1>$argv和$argc</h1>
echo $argc."/n";
print_r($argv);
3/nArray
(
    [0] => test.php
    [1] => aa
    [2] => bb
)
</pre>