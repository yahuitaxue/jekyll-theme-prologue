---
title: PHP设计模式
author: Yahui
layout: php
category: PHP
---


书名：《PHP设计模式》

<pre style="text-align: left;">
一.适配器模式（在需要转化一个对象的接口用于另一个对象时,实现Adapter对象不仅是最佳做法,还能减少很多麻烦）。
	意图：将一个类的接口转换成期望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
	主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
	何时使用： 
		1、系统需要使用现有的类，而此类的接口不符合系统的需要。 
		2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 
		3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）
	如何解决：继承或依赖（推荐）。
	关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。
	使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
	示例:
		interface A {
		    public function defun();
		}
		class A1 implements A {
		    public function defun() {
		        echo '这是A';
		    }
		}

		interface B {
		    public function zhongfun();
		}
		class B1 implements B {
		    public function zhongfun () {
		        echo '这是B';
		    }
		}
		// deal方法只针对A
		class deal {
		    public $sock;
		    public function __construct ($s) {
		        $this->sock = $s;
		    }
		    public function printfun () {
		        $this->sock->defun();
		    }
		}
		// 现在B也要用deal方法,所以要用到适配器进行处理
		class adapter implements A {
		    public $sock;
		    public function __construct ($s) {
		        $this->sock = $s;
		    }
		    public function defun() {
		        $this->sock->zhongfun();
		    }
		}
		$a = new A1();
		$aa = new deal($a);
		$aa -> printfun();

		$b = new B1();
		// 使用适配器进行处理,来适配deal方法
		$bb = new adapter($b);
		$bbb = new deal($bb);
		$bbb -> printfun();
	优点： 
		1、可以让任何两个没有关联的类一起运行。
		2、提高了类的复用。
		3、增加了类的透明度。
		4、灵活性好。
	缺点：
		1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。
		2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。
	注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

二.建造者模式(消除其他对象的创建过程,在某个对象的构造和配置方法改变时可以尽可能的减少重复改代码)
	意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
	主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
	何时使用：一些基本部件不会变，而其组合经常变化的时候。
	如何解决：将变与不变分离开。
	关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
	使用场景：
		1、需要生成的对象具有复杂的内部结构。
		2、需要生成的对象内部属性本身相互依赖。
	应用实例：

	优点： 
		1、建造者独立，易扩展。
		2、便于控制细节风险。
	缺点：
		1、产品必须有共同点，范围有限制。
		2、如内部变化复杂，会有很多的建造类。
	注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。
</pre>