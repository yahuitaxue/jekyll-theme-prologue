---
title: PHP设计模式
author: Yahui
layout: php
category: PHP
---


书名：《PHP设计模式》

<pre style="text-align: left;">
一.适配器模式-结构型模式（在需要转化一个对象的接口用于另一个对象时,实现Adapter对象不仅是最佳做法,还能减少很多麻烦）。
	意图：将一个类的接口转换成期望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
	主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
	何时使用： 
		1、系统需要使用现有的类，而此类的接口不符合系统的需要。 
		2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 
		3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）
	如何解决：继承或依赖（推荐）。
	关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。
	使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
	示例:
		interface A {
		    public function defun();
		}
		class A1 implements A {
		    public function defun() {
		        echo '这是A';
		    }
		}

		interface B {
		    public function zhongfun();
		}
		class B1 implements B {
		    public function zhongfun () {
		        echo '这是B';
		    }
		}
		// deal方法只针对A
		class deal {
		    public $sock;
		    public function __construct ($s) {
		        $this->sock = $s;
		    }
		    public function printfun () {
		        $this->sock->defun();
		    }
		}
		// 现在B也要用deal方法,所以要用到适配器进行处理
		class adapter implements A {
		    public $sock;
		    public function __construct ($s) {
		        $this->sock = $s;
		    }
		    public function defun() {
		        $this->sock->zhongfun();
		    }
		}
		$a = new A1();
		$aa = new deal($a);
		$aa -> printfun();

		$b = new B1();
		// 使用适配器进行处理,来适配deal方法
		$bb = new adapter($b);
		$bbb = new deal($bb);
		$bbb -> printfun();
	优点： 
		1、可以让任何两个没有关联的类一起运行。
		2、提高了类的复用。
		3、增加了类的透明度。
		4、灵活性好。
	缺点：
		1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。
		2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。
	注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

二.建造者模式-创建型模式 (消除其他对象的创建过程,在某个对象的构造和配置方法改变时可以尽可能的减少重复改代码)
	意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
	主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
	何时使用：一些基本部件不会变，而其组合经常变化的时候。
	如何解决：将变与不变分离开。
	关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
	使用场景：
		1、需要生成的对象具有复杂的内部结构。
		2、需要生成的对象内部属性本身相互依赖。
	应用实例：
		class product {
		    public $attrA;
		    public $attrB;
		    public function setAttrA($paramA) {
		        $this -> attrA = $paramA;
		    }
		    public function setAttrB($paramB) {
		        $this -> attrB = $paramB;
		    }
		}
		// 以往需要每个值进行赋值,product修改比较麻烦
		$paramArr = ['a' => 1, 'b' => 2];
		$product = new product();
		$product -> setAttrA($paramArr['a']);
		$product -> setAttrb($paramArr['b']);

		// 使用建造者模式,统一调用,修改起来比较方便
		class builder {
		    public $obj;
		    public function __construct () {
		        $this -> obj = new product();
		    }
		    public function set($paramArr) {
		        $this ->obj -> setAttrA($paramArr['a']);
		        $this ->obj -> setAttrb($paramArr['b']);
		    }
		    public function get() {
		        return $this -> obj;
		    }
		}

		$paramArr = ['a' => 1, 'b' => 2];
		$product = new builder();
		$product -> set($paramArr);
		var_dump((array)$product -> get());
	优点： 
		1、建造者独立，易扩展。
		2、便于控制细节风险。
	缺点：
		1、产品必须有共同点，范围有限制。
		2、如内部变化复杂，会有很多的建造类。
	注意事项：与工厂模式的区别是：建造者模 式更加关注与零件装配的顺序。

三.数据访问对象模式-(低级的数据访问API或操作从高级的业务服务中分离出来)
	数据访问对象模式的参与者:
		数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。
		数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。
		模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。
	使用场景：
		1、减少重复和抽象化数据。
	例子:
		abstract class baseDAO {
		    private $connect;
		    protected $user;
		    protected $pass;
		    protected $host;
		    protected $database;
		    protected $table;
		    protected function __construct() {
		        $this -> __connectToDb();
		    }
		    private function __connectToDb () {
		        // $this -> connect = mysql_connect($this -> host, $this -> user, $this -> pass);
		        // mysql_select_db($this -> database, $this -> connect);
		        echo 'mysql connect ' . $this -> host . ' , ' . $this -> user . ' , ' . $this -> pass . "\r\n";
		    }
		    public function update($condition, $where) {
		        $sql = 'UPDATE '. $this -> table . ' SET ';
		        foreach ($condition as $ckey => $cvalue) {
		            $sql .= $ckey . ' = ' . $cvalue . ',';
		        }
		        $sql = trim($sql, ',') . ' WHERE ';
		        foreach ($where as $wkey => $wvalue) {
		            $sql .= $wkey . ' = ' . $wvalue . ' AND ';
		        }
		        $sql = trim($sql);
		        $sql = trim($sql, 'AND');
		        // mysql_query($sql, $this -> connect);
		        echo $sql;
		    }
		}

		class product extends baseDAO {
		    public function __construct () {
		        $this -> user = 'user1';
		        $this -> pass = 'pass1';
		        $this -> host = 'host1';
		        $this -> database = 'database1';
		        $this -> table = 'product';
		        parent :: __construct();
		    }
		}

		$condition = ['product_id' => 1, 'sku' => 'L1123123'];
		$where = ['stock' => 100, 'name' => '商品A'];
		$producList = new product();
		$producList -> update($condition, $where);

四.装饰器模式-结构型模式(创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能)
	意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
	主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
	何时使用：在不想增加很多子类的情况下扩展类。
	如何解决：将具体功能职责划分，同时继承装饰者模式。
	关键代码： 
		1、Component 类充当抽象角色，不应该具体实现。
		2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。
	应用实例：
		1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。
		2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。
	优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
	缺点：多层装饰比较复杂。
	使用场景：
		1、扩展一个类的功能。
		2、动态增加功能，动态撤销。
	代码示例:
		class demo {
		    public $data;
		    public function __construct () {
		        $this -> data = [];
		    }
		    public function set($params) {
		        foreach ($params as $pkey => $pvalue) {
		            $this -> data [$pkey] = $pvalue;
		        }
		    }
		    public function get() {
		        $str = '';
		        foreach ($this -> data as $gkey => $gvalue) {
		            $str .= $gkey . '=>' . $gvalue . "<br/>";
		        }
		        return $str;
		    }
		}

		$arr = ['a' => 'a', 'b' => 'b', 'c' => 'c'];
		// $d = new demo();
		// $d -> set($arr);
		// echo $d -> get();
		// 现在要返回键值都是大写
		class track {
		    private $obj;
		    public function __construct(demo $demo) {
		        $this -> obj = $demo;
		    }
		    public function deal() {
		        $re = [];
		        foreach ($this ->obj -> data as $dkey => $dvalue) {
		            $re[strtoupper($dkey)] = strtoupper($dvalue);
		        }
		        return $re;
		    }
		}

		$d = new demo();
		$d -> set($arr);
		$re = new track($d);
		$d -> data = $re -> deal();
		echo $d -> get($arr);
	注意事项：可代替继承。

五.代理模式-结构型模式(被代理方(B)与代理方(A)的接口完全一致,类似"中介")
	意图：为其他对象提供一种代理以控制对这个对象的访问。
	主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
	何时使用：想在访问一个类时做一些控制。
	如何解决：增加中间层。
	关键代码：实现与被代理类组合。
	应用实例： 
		1、Windows 里面的快捷方式。 
		2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 
		3、买火车票不一定在火车站买，也可以去代售点。 
		4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。
	优点： 
		1、职责清晰。 
		2、高扩展性。 
		3、智能化。
	缺点： 
		1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
		2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
	使用场景：
		为简化编程（或无法操作B），不直接把请求交给被代理方（B），而把请求交给代码方（A），由代理方与被代理方进行通信，以完成请求。
		按职责来划分，通常有以下使用场景： 
			1、远程代理。 
			2、虚拟代理。 
			3、Copy-on-Write 代理。 
			4、保护（Protect or Access）代理。 
			5、Cache代理。 
			6、防火墙（Firewall）代理。 
			7、同步化（Synchronization）代理。 
			8、智能引用（Smart Reference）代理。
	代码示例:
		interface base {
		    public function say();
		}

		class a implements base {
		    public function say() {
		        echo '服务接口' . '</br>';
		    }
		}
		class b implements base {
		    public $obj;
		    public function __construct($obj) {
		        $this -> obj = $obj;
		    }
		    public function say () {
		        echo '代理模式接口' . '</br>';
		        $this -> obj -> say();
		    }
		}
		$obj = new a();
		$obj -> say();
		$real = new b($obj);
		$real -> say();
	注意事项： 
		1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
		2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

六.委托模式-行为型模式(通过分配或委托至其他对象,委托设计模式能够去除核心对象的判决和复杂的功能性)
	核心：可以理解为静态代理和策略模式一种特殊的组合。
	注: 不要将委托模式视为条件语句的直接竞争者,这是非常重要的,相反,委托设计模式通过不需要条件语句就可以调用正确功能行的方式来帮助构成体系结构,条件语句最好驻留在实际方法中,并且在方法中完成对业务规则的处理.
	代码示例:
		class base {
		    private $data;
		    public function __construct() {
		        $this -> data = [];
		    }
		    public function set($song) {
		        $this -> data = $song;
		    }
		    public function dealA() {
		        foreach ($this -> data as $dkey => $dvalue) {
		            echo 'A is dealing...' . '<br/>';
		        }
		    }
		    public function dealB() {
		        foreach ($this -> data as $dkey => $dvalue) {
		            echo 'B is dealing...' . '<br/>';
		        }
		    }
		}
		$song = ['a', 'b'];
		// $b = new base();
		// $b -> set($song);
		// if (true) {
		//     $b -> dealA();
		// } else {
		//     $b -> dealB();
		// }
		class realDealA{
		    public function getPlayList ($song) {
		        foreach ($song as $akey => $avalue) {
		            echo 'A is dealing...' . '<br/>';
		        }
		    }
		}
		class realDealB{
		    public function getPlayList ($song) {
		        foreach ($song as $bkey => $bvalue) {
		            echo 'B is dealing...' . '<br/>';
		        }
		    }
		}
		class playList {
		    public $str;
		    public function __construct ($type) {
		        $this -> str = 'realDeal' . $type;
		    }
		    public function get($arr) {
		        $obj = new $this -> str;
		        $obj -> getPlayList($arr);
		    }
		}
		$c = new playList('a');
		$c -> get($song);
		$c = new playList('b');
		$c -> get($song);
	注意事项： 
		1、和代理模式的区别：代理模式注重过程,委托模式注重结果。
		
七. 
</pre>